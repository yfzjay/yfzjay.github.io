---
layout: post
title: 'Mysql索引简介'
date: 2020-04-01
author: yza
color: rgb(255,210,32)
cover: '../assets/algorithms.png'
tags: Mysql
typora-copy-images-to: ..\assets\image
---

# 用新华字典来类比解释数据库索引

 **到底什么是索引？** 

用一句话来描述：数据库索引就是一种**加快海量数据查询的关键技术**。现在还不理解这句话？不要紧，往下看，20分钟以后你就能自己做出这样的总结来了。

首先给大家看一张图片

![用新华字典来彻底解释清：数据库索引到底是什么]({{site.baseurl}}/assets/image/1581237251-7695f1fe64dfb54.png)

这本书大家一定都很熟悉，小学入门第一课一定就是教小朋友们学习如何使用这本书。那这和我们的数据库索引有啥关系呢？别着急，我们翻开第一页看看。

![用新华字典来彻底解释清：数据库索引到底是什么]({{site.baseurl}}/assets/image/1581237251-e69bf09e2925642.jpg)

注意右上角的那一排文字，其实目录就是传说中的索引！从前面的“一句话描述”我们可以知道，索引的目的就是为了加快数据查询。那么我们查字典时翻的第一个地方是哪里呢，我相信大部分人都会先翻到拼音目录，毕竟现在很多人都是提笔忘字了😂。

**数据库索引的作用和拼音目录是一样**的，就是最快速的锁定目标数据所在的位置范围。比如我们在这里要查 `险` 这个字，那么我们找到了Xx部分之后就能按顺序找到xian这个拼音所在的页码，根据前后的页码我们可以知道这个字一定是**在519页到523页之间**的，范围一下子就**缩小**到只有4页了。这相比我们从头翻到尾可是快多了，这时候就出现了第一个专业术语——**全表扫描**，也就是我们说的从头找到尾了。

果然，我们在第521页找到了我们要找的“险”字。

![用新华字典来彻底解释清：数据库索引到底是什么]({{site.baseurl}}/assets/image/1581237251-e69bf09e2925642-1.jpg)

那么现在我们就知道数据库索引大概是一个什么东西了：数据库索引是一个类似于目录这样的用来加快数据查询的技术。

------

 **什么是联合索引？** 

相信大家都见过一些**包含多个字段的数据库索引**，比如 `INDEX idx_test(col_a,col_b)`。这种包含多个字段的索引就被称为**“联合索引”**。那么在多个字段上建索引能起到什么样的作用呢？下面还是以新华字典为例，来看看到底什么是联合索引。

新华字典里还有一种目录被称为**“部首目录”**，下面可以看到，要使用这个目录我们首先会根据部首的笔画数找到对应该能的部分，然后可以在里面找到我们想找的部首。比如如果我们还是要找 `险`字所在的位置：

![用新华字典来彻底解释清：数据库索引到底是什么]({{site.baseurl}}/assets/image/1581237251-e69bf09e2925642-2.jpg)

找到部首后，右边的页码还不是 `险`字真正的页码，我们还需要根据右边的页码找到对应部首在检字表中的位置。找到第93页的检字表后我们就可以根据 `险`字**余下的笔画数**（7画）在“6-8画”这一部分里找到 `险`字真正的页码了。

![用新华字典来彻底解释清：数据库索引到底是什么]({{site.baseurl}}/assets/image/1581237252-fab1b895a9605d8.jpg)

在这个过程中，我们按顺序使用了**“两个目录”**，一个叫做**“部首目录”**，一个叫做**“检字表”**。并且我们可以看到上图中检字表的内容都是按部首分门别类组织的。这两个部分合在一起就是我们在本节讨论的主题——联合索引。即通过第一个字段的值（部首）在**第一级索引**中找到对应的**第二级索引**位置（检字表页码），然后在第二级索引中根据第二个字段的值（笔画）找到符合条件的数据所在的位置（险字的真正页码）。

------

 **最左前缀匹配** 

从前面使用部首目录的例子中可以看出，如果我们不知道一个字的部首是什么的话，那基本是没办法使用这个目录的。这说明仅仅通过笔画数（第二个字段）是没办法使用部首目录的。

这就引申出了**联合索引的一个规则**：联合索引中的字段，只有某个字段（笔画）左边的所有字段（部首）都被使用了，才能使用该字段上的索引。例如，有索引 `INDEX idx_i1(col_a,col_b)`，如果查询条件为 `wherecol_b=1`，则无法使用索引 `idx_i1`。

但是如果我们知道部首但是不知道笔画数，比如不知道“横折竖弯勾”是算一笔还是两笔，那我们仍然可以使用“部首目录”部分的内容，只是要把“检字表”对应部首里的所有字都看一遍就能找到我们要找的字了。

这就引申出了**联合索引的另一个规则**：联合索引中的字段，即使某个字段（部首）右边的其他字段（笔画）没有被使用，该字段之前（含）的所有字段仍然可以正常使用索引。例如，有索引 `INDEX idx_i2(col_a,col_b,col_c)`，则查询条件 `wherecol_a=1andcol_b=2`在字段 `col_a`和 `col_b`上仍然可以走索引。

但是，如果我们在确定部首后，不知道一个字到底是两画还是三画，这种情况下我们只需要在对应部首的两画和三画部分中找就可以了，也就是说我们仍然使用了检字表中的内容。所以，使用范围条件查询时也是可以使用索引的。

最后，我们可以完整地表述一下**最左前缀匹配原则的含义**：对于一个**联合索引**，如果有一个SQL查询语句需要执行，则只有从索引最左边的第一个字段开始到SQL语句查询条件中不包含的字段（不含）或范围条件字段（含）为止的部分才会使用索引进行加速。

------

 **什么是聚集索引？** 

从上文的部首目录和拼音目录同时存在但是实际的字典内容只有一份这一点上可以看出，在数据库中**一张表上是可以有多个索引**的。那么不同的索引之间有什么区别呢？

我们在新华字典的侧面可以看到一个V字形的一个个黑色小方块，有很多人都会在侧面写上 `A`, `B`, `C`, `D`这样对应的拼音字母。因为字典中所有的字都是按照拼音顺序排列的，有时候直接使用首字母翻开对应的部分查也很快。

![用新华字典来彻底解释清：数据库索引到底是什么]({{site.baseurl}}/assets/image/1581237252-efaddbd7ef2feef.jpg)

像拼音目录这样的索引，数据会根据索引中的顺序进行排列和组织的，这样的索引就被称为**聚集索引**，而非聚集索引就是其他的一般索引。因为数据只能按照一种规则排序，所以**一张表至多有一个聚集索引**，但可以有多个非聚集索引。

在 MySQL数据库的 InnoDB存储引擎中，**主键索引就是聚集索引**，所有数据都会按照主键索引进行组织；而在MyISAM存储引擎中，就没有聚集索引了，因为MyISAM存储引擎中的数据不是按索引顺序进行存储的。



# Mysql索引底层：B+树

------

## 前言

每当我们执行某个 SQL 发现很慢时，都会下意识地反应是否加了索引，那么大家是否有想过加了索引为啥会使数据查找更快呢，索引的底层一般又是用什么结构存储的呢，相信大家看了标题已经有答案了，没错！B+树！那么它相对于一般的链表，哈希等有何不同，为何多数存储引擎都选择使用它呢，今天我就来揭开 B+ 树的面纱，相信看了此文，B+ 树不再神秘，对你理解以下高频面试题会大有帮助！

- 为啥索引常用 B+ 树作为底层的数据结构
- 除了 B+ 树索引，你还知道什么索引
- 为啥推荐自增 id 作为主键，自建主键不行吗
- 什么是页分裂，页合并
- 怎么根据索引查找行记录

本文将会从以下几个方面来讲解 B+ 树

1. 定义问题
2. 几种常见的数据结构对比
3. 页分裂与页合并

## 定义问题

要知道索引底层为啥使用 B+ 树，得看它解决了什么问题，我们可以想想，日常我们用到的比较多的 SQL 有哪些呢。

假设我们有一张以下的用户表：

```
CREATE TABLE `user` (
  `id`int(11) unsigned NOT NULL AUTO_INCREMENT,
  `name`varchar(20) DEFAULT NULLCOMMENT'姓名',
  `idcard`varchar(20) DEFAULT NULLCOMMENT'身份证号码',
  `age`tinyint(10) DEFAULT NULL COMMENT'年龄',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户信息';
```

一般我们会有如下需求：

**1、根据用户 id 查用户信息**

```
select * from user where id = 123;
```

**2、根据区间值来查找用户信息**

```
select * from user where id > 123 and id < 234;
```

**3、按 id 逆序排列，分页取出用户信息**

```
select * from user where id <  1234 order by id desc limit 10;
```

从以上的几个常用 SQL 我们可以看到索引所用的数据结构必须满足以下三个条件

1. 根据某个值精确快速查找
2. 根据区间值的上下限来快速查找此区间的数据
3. 索引值需要排好序，并支持快速顺序查找和逆序查找

接下来我们以主键索引（id 索引）为例来看看如何用相应的数据结构来构造它

## 几种常见的数据结构对比

接下来我们想想有哪些数据结构满足以上的条件

**1、散列表**

散列表（也称哈希表）是根据关键码值(Key value)而直接进行访问的数据结构，它让码值经过哈希函数的转换映射到散列表对应的位置上，查找效率非常高。哈希索引就是基于散列表实现的，假设我们对名字建立了哈希索引，则查找过程如下图所示：

![img]({{site.baseurl}}/assets/image/640-1585728274353.png)

对于每一行数据，存储引擎都会对所有的索引列（上图中的 name 列）计算一个哈希码（上图散列表的位置），散列表里的每个元素指向数据行的指针，由于索引自身只存储对应的哈希值，所以索引的结构十分紧凑，这让哈希索引查找速度非常快！但是哈希索引也有它的劣势，如下：（**为什么不用Hash来建索引？**）

1. **针对哈希索引，只有精确匹配索引所有列的查询才有效，比如我在列（A,B）上建立了哈希索引，如果只查询数据列 A，则无法使用该索引：无法使用最左前缀规则**
2. **哈希索引并不是按照索引值顺序存存储的，所以也就无法用于排序，也就是说无法根据区间快速查找**
3. **哈希索引只包含哈希值和行指针，不存储字段值，所以不能使用索引中的值来避免读取行，不过，由于哈希索引多数是在内存中完成的，大部分情况下这一点不是问题**
4. **哈希索引只支持等值比较查询，包括 =,IN()，不支持任何范围的查找，如 age > 17**

综上所述，哈希索引只适用于特定场合， 如果用得对，确实能再带来很大的性能提升，如在 InnoDB 引擎中，有一种特殊的功能叫「自适应哈希索引」，如果 InnoDB 注意到某些索引列值被频繁使用时，它会在内存基于 B+ 树索引之上再创建一个哈希索引，这样就能让 B+树也具有哈希索引的优点，比如快速的哈希查找。

**2、链表**

双向链表支持顺序查找和逆序查找，如图下

![img]({{site.baseurl}}/assets/image/640-1585728274354.png)

但显然不支持我们说的按某个值或区间的**快速查找**，另外我们知道表中的数据是要不断增加的，索引也是要及时插入更新的，链表显然也不支持数据的快速插入，所以能否在链表的基础上改造一下，让它支持快速查找，更新，删除。有一种结构刚好能满足我们的需求，这里引入跳表的概念。

什么是跳表?简单地说，跳表是在链表之上加上多层索引构成的。如下图所示

![img]({{site.baseurl}}/assets/image/640-1585728274355.png)

假设我们现在要查找区间 7- 13 的记录，再也不用从头开始查找了，只要在上图中的二级索引开始找即可，遍历三次即可找到链表的区间位置，时间复杂度是 O(logn)，非常快，这样看来，跳表是能满足我们的需求的，实际上它的结构已经和 B+ 树非常接近了，只不过 B+ 树是从平衡二叉查找树演化而来的而已，接下来我们一步步来看下如何将平衡二叉查找树改造成 B+ 树。

先来看看什么是平衡二叉查找树，平衡二叉查找树具有如下性质：

1. 若左子树不空，则左子树上所有节点的值均小于它的根节点的值；
2. 若右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；
3. 每个非叶子节点的左右子树的高度之差的绝对值（平衡因子）最多为1。

下图就是一颗平衡二叉查找树

![img]({{site.baseurl}}/assets/image/640-1585728274356.png)

从其特性就可以看到平衡二叉查找树查找节点的时间复杂度是 O(log2n)

现在我们将其改造成 B+ 树

![img]({{site.baseurl}}/assets/image/640-1585728274379.png)

可以看到主要区别就是所有的节点值都在最后叶节点上用双向链表连接在了一起，仔细和跳表对比一下 ，是不是很像，现在如果我们要找15 ~ 27 这个区间的数只要先找到 15 这个节点（时间复杂度 logn = 3 次）再从前往后遍历直到 27 这个节点即可，即可找到这区间的节点，这样它完美地支持了我们提的三个需求：快速查找值，区间，顺序逆序查找。

假设有 1 亿个节点，每个节点要查询多少次呢，显然最多为  log21亿 =  27 次，如果这 1 亿个节点都在内存里，那 27 次显然不是问题，可以说是非常快了，但一个新的问题出现了，这 1 亿个节点在内存大小是多少呢，我们简单算一下，假设每个节点 16 byte，则 1 亿个节点大概要占用 1.5G 内存！对于内存这么宝贵的资源来说是非常可怕的空间消耗，这还只是一个索引，一般我们都会在表中定义多个索引，或者库中定义多张表，这样的话内存很快就爆满了！所以在内存中完全装载一个 B+ 树索引显然是有问题的，如何解决呢。

内存放不下， 我们可以把它放到磁盘嘛，磁盘空间比内存大多了，但新的问题又来了，我们知道内存与磁盘的读取速度相差太大了，通常内存是纳秒级的，而磁盘是毫秒级的，读取同样大小的数据，两者可能相差上万倍，于是上一步我们计算的 27 次查询如果放在磁盘中来看就非常要命了（查找一个节点可以认为是一次磁盘 IO，也就是说有 27 次磁盘 IO！），27 次查询是否可以优化？

可以很明显地观察到查询次数和树高有关，那树高和什么有关，很明显和每个节点的子节点个数有关，即 N 叉树中的 N，假设现在有 16 个数，我们分别用二叉树和五叉树来构建，看下树高分别是多少

![img]({{site.baseurl}}/assets/image/640-1585728274367.png)

![img]({{site.baseurl}}/assets/image/640-1585728274359.png)

可以看到如果用二叉树 ，要遍历 5 个节点，如果用五叉树 ，只要遍历 3 次，一下少了两次磁盘 IO，回过头来看 上文的一亿个节点，如果我们用 100 叉树来构建，需要几次 IO 呢

![img]({{site.baseurl}}/assets/image/640-1585728274389.png)

可以看到，最多遍历五次（实际上根节点一般存在内存里的，所以可以认为是 4 次）！磁盘 IO 一下从 27 减少到了 5！性能可以说是大大提升了,有人说 5 次还是太多，是不是可以把 100 叉树改成 1000 或 10000 叉树呢，这样 IO 次数不就就能进一步减少了。

这里我们就需要了解页（page）的概念，在计算机里，无论是内存还是磁盘，操作系统都是按页的大小进行读取的（页大小通常为 4 kb），磁盘每次读取都会**预读**，会提前将连续的数据读入内存中，这样就避免了多次 IO，这就是计算机中有名的**局部性原理**，即我用到一块数据，很大可能这块数据附近的数据也会被用到，干脆一起加载，省得多次 IO 拖慢速度， 这个连续数据有多大呢，必须是操作系统页大小的整数倍，这个连续数据就是 MySQL 的页，默认值为 16 KB，也就是说对于 B+ 树的节点，最好设置成页的大小（16 KB），这样一个 B+ 树上的节点就只会有一次 IO 读。

那有人就会问了，这个页大小是不是越大越好呢，设置大一点，节点可容纳的数据就越多，树高越小，IO 不就越小了吗，这里要注意，页大小并不是越大越好，InnoDB 是通过内存中的缓存池（pool buffer）来管理从磁盘中读取的页数据的。页太大的话，很快就把这个缓存池撑满了，可能会造成页在内存与磁盘间频繁换入换出，影响性能。

通过以上分析，相信我们不难猜测出 N 叉树中的 N 该怎么设置了，只要选的时候尽量保证每个节点的大小等于一个页（16kb）的大小即可。

## 页分裂与页合并：为什么推荐自增 id 作为主键

现在我们来看看开头的问题， 为啥推荐自增 id 作为主键，自建主键不行吗，有人可能会说用户的身份证是唯一的，可以用它来做主键，假设以身份证作主键，会有什么问题呢。

主键要用来建索引，B+ 树为了维护索引的有序性，每插入或更新一条记录的时候，会对索引进行更新。假设原来基于身份证作索引的 B+ 树如下（假设为二叉树 ，图中只列出了身份证的前四位）

![img]({{site.baseurl}}/assets/image/640-1585728274401.png)

现在有一个开头是 3604 的身份证对应的记录插入 db ，此时要更新索引，按排序来更新的话，显然这个 3604 的身份证号应该插到左边节点 3504 后面（如下图示，假设为二叉树）

![img]({{site.baseurl}}/assets/image/640-1585728274414.png)

如果把 3604 这个身份证号插入到 3504 后面的话，这个节点的元素个数就有 3 个了，显然不符合二叉树的条件，此时就会造成**页分裂**，就需要调整这个节点以让它符合二叉树的条件

![img]({{site.baseurl}}/assets/image/640-1585728274421.png)

*如图示：调整过后符合二叉树条件*

这种由于页分裂造成的调整必然导致性能的下降，尤其是以身份证作为主键的话，由于身份证的随机性，必然造成大量的随机结点中的插入，进而造成大量的页分裂，进而造成性能的急剧下降，那如果是以自增 id 作为主键呢，由于新插入的表中生成的 id 比索引中所有的值都大，所以它要么合到已存在的节点（元素个数未满）中，要么放入新建的节点中（如下图示）所以如果是以自增 id 作为主键，就不存在页分裂的问题了，推荐！

![img]({{site.baseurl}}/assets/image/640-1585728274406.png)

有页分裂就必然有页合并，什么时候会发生页合并呢，当删除表记录的时候，索引也要删除，此时就有可能发生页合并，如图示

![img]({{site.baseurl}}/assets/image/640-1585728274428.png)

当我们删除 id 为 7，9 对应行的时候，上图中的索引就要更新，把 7，9 删掉，此时 8，10 就应该合到一个节点，不然 8，10 分散在两个节点上，可能造成两次 IO 读，势必会影响查找效率! 那什么时候会发生页合并呢，我们可以定个阈值，比如对于 N 叉树来说，当节点的个数小于 N/2 的时候就应该和附近的节点合并，不过需要注意的是合并后节点里的元素大小可能会超过 N，造成页分裂，需要再对父节点等进行调整以让它满足 N 叉树的条件。

## 怎么根据索引查找行记录

相信大家看完以上的 B+ 树索引的介绍应该还有个疑惑，怎么根据对应的索引值查找行记录呢，其实相应的行记录就放在最后的叶子节点中，找到了索引值，也就找到了行记录。如图示

![img]({{site.baseurl}}/assets/image/640-1585728274435.png)

可以看到，非叶子节点只存了索引值，只在最后一行才存放了行记录，这样极大地减小了索引了大小，而且只要找到索引值就找到了行记录，也提升了效率，

**这种在叶节点存放一整行记录的索引被称为聚簇索引，其他的就称为非聚簇索引。也就是说聚簇索引存放顺序和数据存放数据相同。**

## 关于 B+ 树的总结

综上所述，B+树有以下特点：

- 每个节点中子节点的个数不能超过 m，也不能小于 m/2（不然会造成页分裂或页合并）
- 根节点的子节点个数可以不超过 m/2，这是一个例外
- m 叉树只存储索引，并不真正存储数据，只有最后一行的叶子节点存储行数据。
- 通过链表将叶子节点串联在一起，这样可以方便按区间查找

为什么不用平衡二叉树和为什么不尽量多路：

1）B+树叶子结点链在一起，可以一次性的范围查找，在范围内顺序查找。

2）B+树和平衡二叉树的比较次数可能相同或者大于平衡二叉树，但是由于数据量大时索引不会在内存中而是在磁盘中，B+树的一个节点中存放多个索引，因此树高会大大降低，磁盘I/O次数也就大大减少，磁盘操作通常在毫秒级，而内存计算在纳秒级，相差上万倍，所以B+树就比平衡二叉树快多了。

3）为什么不尽量多路：内存读取会按页读取，页的大小是4KB，而且计算机会预读，读到的连续数据16KB，如果节点中的数据大于16KB，一样会造成多次I/O，因此计算几路B+树时要使一个节点中的数据在16KB左右。那为什么又不扩展页的大小呢？设置大一点，节点可容纳的数据就越多，树高越小，IO 不就越小了吗，这里要注意，页大小并不是越大越好，InnoDB 是通过内存中的缓存池（pool buffer）来管理从磁盘中读取的页数据的。页太大的话，很快就把这个缓存池撑满了，可能会造成页在内存与磁盘间频繁换入换出，影响性能。