---
layout: post
title: '异常'
date: 2020-02-08
author: yza
color: rgb(255,210,32)
cover: '../assets/java.jpg'
tags: java java基础
typora-copy-images-to: ..\assets\image
---

**1、Java中的异常大体分为Expection和Error。Expection下又分为RuntimeEx和可检查异常。**

**2、Error：Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机（JVM）一般会选择终止线程。Error类对象由 Java 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。例如，Java虚拟机运行错误（Virtual MachineError），当JVM不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止；还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError）、链接错误（LinkageError）。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在Java中，错误通常是使用Error的子类描述。**

**3、运行时异常如ArrayIndexOutOfBoundsException（数组下标越界）、NullPointerException（空指针异常）、ArithmeticException（算术异常）、MissingResourceException（丢失资源）、ClassNotFoundException（找不到类），当可能出现这些异常时，不要求程序去处理，如果真的发生了，并且程序没有主动处理，就由系统处理，中断程序，抛到调用该方法的地方，如果直到最外层Main也没有处理，就打印错误信息。**

**4、检查异常要求程序必须去处理，当代码可能引发检查异常时，要么就地catch要么向外层抛出，否则编译不会通过。检查异常包括IOEx,SQLEx等。**

**5、嵌套try语句：try语句可以被嵌套。也就是说，一个try语句可以在另一个try块的内部。每次进入try语句，异常的前后关系都会被推入堆栈。如果一个内部的try语句不含特殊异常的catch处理程序，堆栈将弹出，外层try语句的catch处理程序将检查是否与之匹配。这个过程将继续直到一个catch语句被匹配成功，或者是直到所有的嵌套try语句被检查完毕。如果没有catch语句匹配，Java运行时系统将处理这个异常。当有方法调用时，try语句的嵌套可以很隐蔽的发生。例如，我们可以将对方法的调用放在一个try块中。在该方法的内部，有另一个try语句。在这种情况下，方法内部的try仍然是嵌套在外部调用该方法的try块中的。**

**6、上述说的异常大多是由程序运行时系统引发的，然而我们也可以自己引发异常：用throw new ex语句，即创建一个异常对象。当执行到这句话时，可能会就地catch，可能会throws到外层处理，可能由系统处理异常抛出错误信息，具体的做法和由程序引发的异常是相同的，见上述。**

**7、finally：当异常发生时，通常方法的执行将做一个陡峭的非线性的转向，它甚至会过早的导致方法返回。例如，如果一个方法打开了一个文件并关闭，然后退出，你不希望关闭文件的代码被异常处理机制旁路。finally关键字为处理这种意外而设计。finally创建的代码块在try/catch块完成之后另一个try/catch出现之前执行。finally块无论有没有异常抛出都会执行。如果抛出异常，即使没有catch子句匹配，finally也会执行。一个方法将从一个try/catch块返回到调用程序的任何时候，经过一个未捕获的异常或者是一个明确的返回语句，finally子句在方法返回之前仍将执行。这在关闭文件句柄和释放任何在方法开始时被分配的其他资源是很有用。**

**8、异常链：当程序捕获到了一个底层异常，在处理部分选择了继续抛出一个更高级别的新异常给此方法的调用者。 这样异常的原因就会逐层传递。这样，位于高层的异常递归调用getCause()方法，就可以遍历各层的异常原因。 这就是Java异常链的原理。异常链的实际应用很少，发生异常时候逐层上抛不是个好注意， 上层拿到这些异常又能奈之何？而且异常逐层上抛会消耗大量资源， 因为要保存一个完整的异常链信息。需要注意的是，如果在catch中抛出的异常属于可检查异常，要么继续加一个catch（那就不是异常链了），要么throws到外层，因为系统不会帮你向外层抛。**

**9、当就地catch时，即使throws也不会触发了，因为已经被处理了。**

**10、自定义异常：使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可。**
**在程序中使用自定义异常类，大体可分为以下几个步骤:**
**创建自定义异常类。**
**在方法中通过throw关键字抛出异常对象。**
**如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作，在出现异常方法的调用者中捕获并处理异常。**

**11、其实可以这么简单地认为：非检查异常是系统帮你throws到最外层，直到main函数仍没有被处理就在main方法处也throws。而可检查异常必须手动throws（或catch），效果是一样的。**